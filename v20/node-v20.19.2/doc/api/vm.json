{
  "type": "module",
  "source": "doc/api/vm.md",
  "modules": [
    {
      "textRaw": "VM (executing JavaScript)",
      "name": "vm",
      "introduced_in": "v0.10.0",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p><strong>Source Code:</strong> <a href=\"https://github.com/nodejs/node/blob/v20.19.2/lib/vm.js\">lib/vm.js</a></p>\n<p>The <code>node:vm</code> module enables compiling and running code within V8 Virtual\nMachine contexts.</p>\n<p><strong class=\"critical\">The <code>node:vm</code> module is not a security\nmechanism. Do not use it to run untrusted code.</strong></p>\n<p>JavaScript code can be compiled and run immediately or\ncompiled, saved, and run later.</p>\n<p>A common use case is to run the code in a different V8 Context. This means\ninvoked code has a different global object than the invoking code.</p>\n<p>One can provide the context by <a href=\"#what-does-it-mean-to-contextify-an-object\"><em>contextifying</em></a> an\nobject. The invoked code treats any property in the context like a\nglobal variable. Any changes to global variables caused by the invoked\ncode are reflected in the context object.</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nconst x = 1;\n\nconst context = { x: 2 };\nvm.createContext(context); // Contextify the object.\n\nconst code = 'x += 40; var y = 17;';\n// `x` and `y` are global variables in the context.\n// Initially, x has the value 2 because that is the value of context.x.\nvm.runInContext(code, context);\n\nconsole.log(context.x); // 42\nconsole.log(context.y); // 17\n\nconsole.log(x); // 1; y is not defined.\n</code></pre>",
      "classes": [
        {
          "textRaw": "Class: `vm.Script`",
          "type": "class",
          "name": "vm.Script",
          "meta": {
            "added": [
              "v0.3.1"
            ],
            "changes": []
          },
          "desc": "<p>Instances of the <code>vm.Script</code> class contain precompiled scripts that can be\nexecuted in specific contexts.</p>",
          "properties": [
            {
              "textRaw": "`cachedDataRejected` {boolean|undefined}",
              "type": "boolean|undefined",
              "name": "cachedDataRejected",
              "meta": {
                "added": [
                  "v5.7.0"
                ],
                "changes": []
              },
              "desc": "<p>When <code>cachedData</code> is supplied to create the <code>vm.Script</code>, this value will be set\nto either <code>true</code> or <code>false</code> depending on acceptance of the data by V8.\nOtherwise the value is <code>undefined</code>.</p>"
            },
            {
              "textRaw": "`sourceMapURL` {string|undefined}",
              "type": "string|undefined",
              "name": "sourceMapURL",
              "meta": {
                "added": [
                  "v19.1.0",
                  "v18.13.0"
                ],
                "changes": []
              },
              "desc": "<p>When the script is compiled from a source that contains a source map magic\ncomment, this property will be set to the URL of the source map.</p>\n<pre><code class=\"language-mjs\">import vm from 'node:vm';\n\nconst script = new vm.Script(`\nfunction myFunc() {}\n//# sourceMappingURL=sourcemap.json\n`);\n\nconsole.log(script.sourceMapURL);\n// Prints: sourcemap.json\n</code></pre>\n<pre><code class=\"language-cjs\">const vm = require('node:vm');\n\nconst script = new vm.Script(`\nfunction myFunc() {}\n//# sourceMappingURL=sourcemap.json\n`);\n\nconsole.log(script.sourceMapURL);\n// Prints: sourcemap.json\n</code></pre>"
            }
          ],
          "methods": [
            {
              "textRaw": "`script.createCachedData()`",
              "type": "method",
              "name": "createCachedData",
              "meta": {
                "added": [
                  "v10.6.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer}",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Creates a code cache that can be used with the <code>Script</code> constructor's\n<code>cachedData</code> option. Returns a <code>Buffer</code>. This method may be called at any\ntime and any number of times.</p>\n<p>The code cache of the <code>Script</code> doesn't contain any JavaScript observable\nstates. The code cache is safe to be saved along side the script source and\nused to construct new <code>Script</code> instances multiple times.</p>\n<p>Functions in the <code>Script</code> source can be marked as lazily compiled and they are\nnot compiled at construction of the <code>Script</code>. These functions are going to be\ncompiled when they are invoked the first time. The code cache serializes the\nmetadata that V8 currently knows about the <code>Script</code> that it can use to speed up\nfuture compilations.</p>\n<pre><code class=\"language-js\">const script = new vm.Script(`\nfunction add(a, b) {\n  return a + b;\n}\n\nconst x = add(1, 2);\n`);\n\nconst cacheWithoutAdd = script.createCachedData();\n// In `cacheWithoutAdd` the function `add()` is marked for full compilation\n// upon invocation.\n\nscript.runInThisContext();\n\nconst cacheWithAdd = script.createCachedData();\n// `cacheWithAdd` contains fully compiled function `add()`.\n</code></pre>"
            },
            {
              "textRaw": "`script.runInContext(contextifiedObject[, options])`",
              "type": "method",
              "name": "runInContext",
              "meta": {
                "added": [
                  "v0.3.1"
                ],
                "changes": [
                  {
                    "version": "v6.3.0",
                    "pr-url": "https://github.com/nodejs/node/pull/6635",
                    "description": "The `breakOnSigint` option is supported now."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {any} the result of the very last statement executed in the script.",
                    "name": "return",
                    "type": "any",
                    "desc": "the result of the very last statement executed in the script."
                  },
                  "params": [
                    {
                      "textRaw": "`contextifiedObject` {Object} A [contextified][] object as returned by the `vm.createContext()` method.",
                      "name": "contextifiedObject",
                      "type": "Object",
                      "desc": "A [contextified][] object as returned by the `vm.createContext()` method."
                    },
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`displayErrors` {boolean} When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace. **Default:** `true`.",
                          "name": "displayErrors",
                          "type": "boolean",
                          "default": "`true`",
                          "desc": "When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace."
                        },
                        {
                          "textRaw": "`timeout` {integer} Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer.",
                          "name": "timeout",
                          "type": "integer",
                          "desc": "Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer."
                        },
                        {
                          "textRaw": "`breakOnSigint` {boolean} If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that. **Default:** `false`.",
                          "name": "breakOnSigint",
                          "type": "boolean",
                          "default": "`false`",
                          "desc": "If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>Runs the compiled code contained by the <code>vm.Script</code> object within the given\n<code>contextifiedObject</code> and returns the result. Running code does not have access\nto local scope.</p>\n<p>The following example compiles code that increments a global variable, sets\nthe value of another global variable, then execute the code multiple times.\nThe globals are contained in the <code>context</code> object.</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nconst context = {\n  animal: 'cat',\n  count: 2,\n};\n\nconst script = new vm.Script('count += 1; name = \"kitty\";');\n\nvm.createContext(context);\nfor (let i = 0; i &#x3C; 10; ++i) {\n  script.runInContext(context);\n}\n\nconsole.log(context);\n// Prints: { animal: 'cat', count: 12, name: 'kitty' }\n</code></pre>\n<p>Using the <code>timeout</code> or <code>breakOnSigint</code> options will result in new event loops\nand corresponding threads being started, which have a non-zero performance\noverhead.</p>"
            },
            {
              "textRaw": "`script.runInNewContext([contextObject[, options]])`",
              "type": "method",
              "name": "runInNewContext",
              "meta": {
                "added": [
                  "v0.3.1"
                ],
                "changes": [
                  {
                    "version": "v20.18.0",
                    "pr-url": "https://github.com/nodejs/node/pull/54394",
                    "description": "The `contextObject` argument now accepts `vm.constants.DONT_CONTEXTIFY`."
                  },
                  {
                    "version": "v14.6.0",
                    "pr-url": "https://github.com/nodejs/node/pull/34023",
                    "description": "The `microtaskMode` option is supported now."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/19016",
                    "description": "The `contextCodeGeneration` option is supported now."
                  },
                  {
                    "version": "v6.3.0",
                    "pr-url": "https://github.com/nodejs/node/pull/6635",
                    "description": "The `breakOnSigint` option is supported now."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {any} the result of the very last statement executed in the script.",
                    "name": "return",
                    "type": "any",
                    "desc": "the result of the very last statement executed in the script."
                  },
                  "params": [
                    {
                      "textRaw": "`contextObject` {Object|vm.constants.DONT\\_CONTEXTIFY|undefined} Either [`vm.constants.DONT_CONTEXTIFY`][] or an object that will be [contextified][]. If `undefined`, an empty contextified object will be created for backwards compatibility.",
                      "name": "contextObject",
                      "type": "Object|vm.constants.DONT\\_CONTEXTIFY|undefined",
                      "desc": "Either [`vm.constants.DONT_CONTEXTIFY`][] or an object that will be [contextified][]. If `undefined`, an empty contextified object will be created for backwards compatibility."
                    },
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`displayErrors` {boolean} When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace. **Default:** `true`.",
                          "name": "displayErrors",
                          "type": "boolean",
                          "default": "`true`",
                          "desc": "When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace."
                        },
                        {
                          "textRaw": "`timeout` {integer} Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer.",
                          "name": "timeout",
                          "type": "integer",
                          "desc": "Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer."
                        },
                        {
                          "textRaw": "`breakOnSigint` {boolean} If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that. **Default:** `false`.",
                          "name": "breakOnSigint",
                          "type": "boolean",
                          "default": "`false`",
                          "desc": "If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that."
                        },
                        {
                          "textRaw": "`contextName` {string} Human-readable name of the newly created context. **Default:** `'VM Context i'`, where `i` is an ascending numerical index of the created context.",
                          "name": "contextName",
                          "type": "string",
                          "default": "`'VM Context i'`, where `i` is an ascending numerical index of the created context",
                          "desc": "Human-readable name of the newly created context."
                        },
                        {
                          "textRaw": "`contextOrigin` {string} [Origin][origin] corresponding to the newly created context for display purposes. The origin should be formatted like a URL, but with only the scheme, host, and port (if necessary), like the value of the [`url.origin`][] property of a [`URL`][] object. Most notably, this string should omit the trailing slash, as that denotes a path. **Default:** `''`.",
                          "name": "contextOrigin",
                          "type": "string",
                          "default": "`''`",
                          "desc": "[Origin][origin] corresponding to the newly created context for display purposes. The origin should be formatted like a URL, but with only the scheme, host, and port (if necessary), like the value of the [`url.origin`][] property of a [`URL`][] object. Most notably, this string should omit the trailing slash, as that denotes a path."
                        },
                        {
                          "textRaw": "`contextCodeGeneration` {Object}",
                          "name": "contextCodeGeneration",
                          "type": "Object",
                          "options": [
                            {
                              "textRaw": "`strings` {boolean} If set to false any calls to `eval` or function constructors (`Function`, `GeneratorFunction`, etc) will throw an `EvalError`. **Default:** `true`.",
                              "name": "strings",
                              "type": "boolean",
                              "default": "`true`",
                              "desc": "If set to false any calls to `eval` or function constructors (`Function`, `GeneratorFunction`, etc) will throw an `EvalError`."
                            },
                            {
                              "textRaw": "`wasm` {boolean} If set to false any attempt to compile a WebAssembly module will throw a `WebAssembly.CompileError`. **Default:** `true`.",
                              "name": "wasm",
                              "type": "boolean",
                              "default": "`true`",
                              "desc": "If set to false any attempt to compile a WebAssembly module will throw a `WebAssembly.CompileError`."
                            }
                          ]
                        },
                        {
                          "textRaw": "`microtaskMode` {string} If set to `afterEvaluate`, microtasks (tasks scheduled through `Promise`s and `async function`s) will be run immediately after the script has run. They are included in the `timeout` and `breakOnSigint` scopes in that case.",
                          "name": "microtaskMode",
                          "type": "string",
                          "desc": "If set to `afterEvaluate`, microtasks (tasks scheduled through `Promise`s and `async function`s) will be run immediately after the script has run. They are included in the `timeout` and `breakOnSigint` scopes in that case."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>This method is a shortcut to <code>script.runInContext(vm.createContext(options), options)</code>.\nIt does several things at once:</p>\n<ol>\n<li>Creates a new context.</li>\n<li>If <code>contextObject</code> is an object, <a href=\"#what-does-it-mean-to-contextify-an-object\">contextifies</a> it with the new context.\nIf  <code>contextObject</code> is undefined, creates a new object and <a href=\"#what-does-it-mean-to-contextify-an-object\">contextifies</a> it.\nIf <code>contextObject</code> is <a href=\"#vmconstantsdont_contextify\"><code>vm.constants.DONT_CONTEXTIFY</code></a>, don't <a href=\"#what-does-it-mean-to-contextify-an-object\">contextify</a> anything.</li>\n<li>Runs the compiled code contained by the <code>vm.Script</code> object within the created context. The code\ndoes not have access to the scope in which this method is called.</li>\n<li>Returns the result.</li>\n</ol>\n<p>The following example compiles code that sets a global variable, then executes\nthe code multiple times in different contexts. The globals are set on and\ncontained within each individual <code>context</code>.</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nconst script = new vm.Script('globalVar = \"set\"');\n\nconst contexts = [{}, {}, {}];\ncontexts.forEach((context) => {\n  script.runInNewContext(context);\n});\n\nconsole.log(contexts);\n// Prints: [{ globalVar: 'set' }, { globalVar: 'set' }, { globalVar: 'set' }]\n\n// This would throw if the context is created from a contextified object.\n// vm.constants.DONT_CONTEXTIFY allows creating contexts with ordinary\n// global objects that can be frozen.\nconst freezeScript = new vm.Script('Object.freeze(globalThis); globalThis;');\nconst frozenContext = freezeScript.runInNewContext(vm.constants.DONT_CONTEXTIFY);\n</code></pre>"
            },
            {
              "textRaw": "`script.runInThisContext([options])`",
              "type": "method",
              "name": "runInThisContext",
              "meta": {
                "added": [
                  "v0.3.1"
                ],
                "changes": [
                  {
                    "version": "v6.3.0",
                    "pr-url": "https://github.com/nodejs/node/pull/6635",
                    "description": "The `breakOnSigint` option is supported now."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {any} the result of the very last statement executed in the script.",
                    "name": "return",
                    "type": "any",
                    "desc": "the result of the very last statement executed in the script."
                  },
                  "params": [
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`displayErrors` {boolean} When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace. **Default:** `true`.",
                          "name": "displayErrors",
                          "type": "boolean",
                          "default": "`true`",
                          "desc": "When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace."
                        },
                        {
                          "textRaw": "`timeout` {integer} Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer.",
                          "name": "timeout",
                          "type": "integer",
                          "desc": "Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer."
                        },
                        {
                          "textRaw": "`breakOnSigint` {boolean} If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that. **Default:** `false`.",
                          "name": "breakOnSigint",
                          "type": "boolean",
                          "default": "`false`",
                          "desc": "If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>Runs the compiled code contained by the <code>vm.Script</code> within the context of the\ncurrent <code>global</code> object. Running code does not have access to local scope, but\n<em>does</em> have access to the current <code>global</code> object.</p>\n<p>The following example compiles code that increments a <code>global</code> variable then\nexecutes that code multiple times:</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nglobal.globalVar = 0;\n\nconst script = new vm.Script('globalVar += 1', { filename: 'myfile.vm' });\n\nfor (let i = 0; i &#x3C; 1000; ++i) {\n  script.runInThisContext();\n}\n\nconsole.log(globalVar);\n\n// 1000\n</code></pre>"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`code` {string} The JavaScript code to compile.",
                  "name": "code",
                  "type": "string",
                  "desc": "The JavaScript code to compile."
                },
                {
                  "textRaw": "`options` {Object|string}",
                  "name": "options",
                  "type": "Object|string",
                  "options": [
                    {
                      "textRaw": "`filename` {string} Specifies the filename used in stack traces produced by this script. **Default:** `'evalmachine.<anonymous>'`.",
                      "name": "filename",
                      "type": "string",
                      "default": "`'evalmachine.<anonymous>'`",
                      "desc": "Specifies the filename used in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`lineOffset` {number} Specifies the line number offset that is displayed in stack traces produced by this script. **Default:** `0`.",
                      "name": "lineOffset",
                      "type": "number",
                      "default": "`0`",
                      "desc": "Specifies the line number offset that is displayed in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`columnOffset` {number} Specifies the first-line column number offset that is displayed in stack traces produced by this script. **Default:** `0`.",
                      "name": "columnOffset",
                      "type": "number",
                      "default": "`0`",
                      "desc": "Specifies the first-line column number offset that is displayed in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`cachedData` {Buffer|TypedArray|DataView} Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source. When supplied, the `cachedDataRejected` value will be set to either `true` or `false` depending on acceptance of the data by V8.",
                      "name": "cachedData",
                      "type": "Buffer|TypedArray|DataView",
                      "desc": "Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source. When supplied, the `cachedDataRejected` value will be set to either `true` or `false` depending on acceptance of the data by V8."
                    },
                    {
                      "textRaw": "`produceCachedData` {boolean} When `true` and no `cachedData` is present, V8 will attempt to produce code cache data for `code`. Upon success, a `Buffer` with V8's code cache data will be produced and stored in the `cachedData` property of the returned `vm.Script` instance. The `cachedDataProduced` value will be set to either `true` or `false` depending on whether code cache data is produced successfully. This option is **deprecated** in favor of `script.createCachedData()`. **Default:** `false`.",
                      "name": "produceCachedData",
                      "type": "boolean",
                      "default": "`false`",
                      "desc": "When `true` and no `cachedData` is present, V8 will attempt to produce code cache data for `code`. Upon success, a `Buffer` with V8's code cache data will be produced and stored in the `cachedData` property of the returned `vm.Script` instance. The `cachedDataProduced` value will be set to either `true` or `false` depending on whether code cache data is produced successfully. This option is **deprecated** in favor of `script.createCachedData()`."
                    },
                    {
                      "textRaw": "`importModuleDynamically` {Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER} Used to specify how the modules should be loaded during the evaluation of this script when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][].",
                      "name": "importModuleDynamically",
                      "type": "Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER",
                      "desc": "Used to specify how the modules should be loaded during the evaluation of this script when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][]."
                    }
                  ]
                }
              ],
              "desc": "<p>If <code>options</code> is a string, then it specifies the filename.</p>\n<p>Creating a new <code>vm.Script</code> object compiles <code>code</code> but does not run it. The\ncompiled <code>vm.Script</code> can be run later multiple times. The <code>code</code> is not bound to\nany global object; rather, it is bound before each run, just for that run.</p>"
            }
          ]
        },
        {
          "textRaw": "Class: `vm.Module`",
          "type": "class",
          "name": "vm.Module",
          "meta": {
            "added": [
              "v13.0.0",
              "v12.16.0"
            ],
            "changes": []
          },
          "stability": 1,
          "stabilityText": "Experimental",
          "desc": "<p>This feature is only available with the <code>--experimental-vm-modules</code> command\nflag enabled.</p>\n<p>The <code>vm.Module</code> class provides a low-level interface for using\nECMAScript modules in VM contexts. It is the counterpart of the <code>vm.Script</code>\nclass that closely mirrors <a href=\"https://262.ecma-international.org/14.0/#sec-abstract-module-records\">Module Record</a>s as defined in the ECMAScript\nspecification.</p>\n<p>Unlike <code>vm.Script</code> however, every <code>vm.Module</code> object is bound to a context from\nits creation. Operations on <code>vm.Module</code> objects are intrinsically asynchronous,\nin contrast with the synchronous nature of <code>vm.Script</code> objects. The use of\n'async' functions can help with manipulating <code>vm.Module</code> objects.</p>\n<p>Using a <code>vm.Module</code> object requires three distinct steps: creation/parsing,\nlinking, and evaluation. These three steps are illustrated in the following\nexample.</p>\n<p>This implementation lies at a lower level than the <a href=\"esm.html#modules-ecmascript-modules\">ECMAScript Module\nloader</a>. There is also no way to interact with the Loader yet, though\nsupport is planned.</p>\n<pre><code class=\"language-mjs\">import vm from 'node:vm';\n\nconst contextifiedObject = vm.createContext({\n  secret: 42,\n  print: console.log,\n});\n\n// Step 1\n//\n// Create a Module by constructing a new `vm.SourceTextModule` object. This\n// parses the provided source text, throwing a `SyntaxError` if anything goes\n// wrong. By default, a Module is created in the top context. But here, we\n// specify `contextifiedObject` as the context this Module belongs to.\n//\n// Here, we attempt to obtain the default export from the module \"foo\", and\n// put it into local binding \"secret\".\n\nconst bar = new vm.SourceTextModule(`\n  import s from 'foo';\n  s;\n  print(s);\n`, { context: contextifiedObject });\n\n// Step 2\n//\n// \"Link\" the imported dependencies of this Module to it.\n//\n// The provided linking callback (the \"linker\") accepts two arguments: the\n// parent module (`bar` in this case) and the string that is the specifier of\n// the imported module. The callback is expected to return a Module that\n// corresponds to the provided specifier, with certain requirements documented\n// in `module.link()`.\n//\n// If linking has not started for the returned Module, the same linker\n// callback will be called on the returned Module.\n//\n// Even top-level Modules without dependencies must be explicitly linked. The\n// callback provided would never be called, however.\n//\n// The link() method returns a Promise that will be resolved when all the\n// Promises returned by the linker resolve.\n//\n// Note: This is a contrived example in that the linker function creates a new\n// \"foo\" module every time it is called. In a full-fledged module system, a\n// cache would probably be used to avoid duplicated modules.\n\nasync function linker(specifier, referencingModule) {\n  if (specifier === 'foo') {\n    return new vm.SourceTextModule(`\n      // The \"secret\" variable refers to the global variable we added to\n      // \"contextifiedObject\" when creating the context.\n      export default secret;\n    `, { context: referencingModule.context });\n\n    // Using `contextifiedObject` instead of `referencingModule.context`\n    // here would work as well.\n  }\n  throw new Error(`Unable to resolve dependency: ${specifier}`);\n}\nawait bar.link(linker);\n\n// Step 3\n//\n// Evaluate the Module. The evaluate() method returns a promise which will\n// resolve after the module has finished evaluating.\n\n// Prints 42.\nawait bar.evaluate();\n</code></pre>\n<pre><code class=\"language-cjs\">const vm = require('node:vm');\n\nconst contextifiedObject = vm.createContext({\n  secret: 42,\n  print: console.log,\n});\n\n(async () => {\n  // Step 1\n  //\n  // Create a Module by constructing a new `vm.SourceTextModule` object. This\n  // parses the provided source text, throwing a `SyntaxError` if anything goes\n  // wrong. By default, a Module is created in the top context. But here, we\n  // specify `contextifiedObject` as the context this Module belongs to.\n  //\n  // Here, we attempt to obtain the default export from the module \"foo\", and\n  // put it into local binding \"secret\".\n\n  const bar = new vm.SourceTextModule(`\n    import s from 'foo';\n    s;\n    print(s);\n  `, { context: contextifiedObject });\n\n  // Step 2\n  //\n  // \"Link\" the imported dependencies of this Module to it.\n  //\n  // The provided linking callback (the \"linker\") accepts two arguments: the\n  // parent module (`bar` in this case) and the string that is the specifier of\n  // the imported module. The callback is expected to return a Module that\n  // corresponds to the provided specifier, with certain requirements documented\n  // in `module.link()`.\n  //\n  // If linking has not started for the returned Module, the same linker\n  // callback will be called on the returned Module.\n  //\n  // Even top-level Modules without dependencies must be explicitly linked. The\n  // callback provided would never be called, however.\n  //\n  // The link() method returns a Promise that will be resolved when all the\n  // Promises returned by the linker resolve.\n  //\n  // Note: This is a contrived example in that the linker function creates a new\n  // \"foo\" module every time it is called. In a full-fledged module system, a\n  // cache would probably be used to avoid duplicated modules.\n\n  async function linker(specifier, referencingModule) {\n    if (specifier === 'foo') {\n      return new vm.SourceTextModule(`\n        // The \"secret\" variable refers to the global variable we added to\n        // \"contextifiedObject\" when creating the context.\n        export default secret;\n      `, { context: referencingModule.context });\n\n      // Using `contextifiedObject` instead of `referencingModule.context`\n      // here would work as well.\n    }\n    throw new Error(`Unable to resolve dependency: ${specifier}`);\n  }\n  await bar.link(linker);\n\n  // Step 3\n  //\n  // Evaluate the Module. The evaluate() method returns a promise which will\n  // resolve after the module has finished evaluating.\n\n  // Prints 42.\n  await bar.evaluate();\n})();\n</code></pre>",
          "properties": [
            {
              "textRaw": "`dependencySpecifiers` {string\\[]}",
              "type": "string\\[]",
              "name": "dependencySpecifiers",
              "desc": "<p>The specifiers of all dependencies of this module. The returned array is frozen\nto disallow any changes to it.</p>\n<p>Corresponds to the <code>[[RequestedModules]]</code> field of <a href=\"https://tc39.es/ecma262/#sec-cyclic-module-records\">Cyclic Module Record</a>s in\nthe ECMAScript specification.</p>"
            },
            {
              "textRaw": "`error` {any}",
              "type": "any",
              "name": "error",
              "desc": "<p>If the <code>module.status</code> is <code>'errored'</code>, this property contains the exception\nthrown by the module during evaluation. If the status is anything else,\naccessing this property will result in a thrown exception.</p>\n<p>The value <code>undefined</code> cannot be used for cases where there is not a thrown\nexception due to possible ambiguity with <code>throw undefined;</code>.</p>\n<p>Corresponds to the <code>[[EvaluationError]]</code> field of <a href=\"https://tc39.es/ecma262/#sec-cyclic-module-records\">Cyclic Module Record</a>s\nin the ECMAScript specification.</p>"
            },
            {
              "textRaw": "`identifier` {string}",
              "type": "string",
              "name": "identifier",
              "desc": "<p>The identifier of the current module, as set in the constructor.</p>"
            },
            {
              "textRaw": "`namespace` {Object}",
              "type": "Object",
              "name": "namespace",
              "desc": "<p>The namespace object of the module. This is only available after linking\n(<code>module.link()</code>) has completed.</p>\n<p>Corresponds to the <a href=\"https://tc39.es/ecma262/#sec-getmodulenamespace\">GetModuleNamespace</a> abstract operation in the ECMAScript\nspecification.</p>"
            },
            {
              "textRaw": "`status` {string}",
              "type": "string",
              "name": "status",
              "desc": "<p>The current status of the module. Will be one of:</p>\n<ul>\n<li>\n<p><code>'unlinked'</code>: <code>module.link()</code> has not yet been called.</p>\n</li>\n<li>\n<p><code>'linking'</code>: <code>module.link()</code> has been called, but not all Promises returned\nby the linker function have been resolved yet.</p>\n</li>\n<li>\n<p><code>'linked'</code>: The module has been linked successfully, and all of its\ndependencies are linked, but <code>module.evaluate()</code> has not yet been called.</p>\n</li>\n<li>\n<p><code>'evaluating'</code>: The module is being evaluated through a <code>module.evaluate()</code> on\nitself or a parent module.</p>\n</li>\n<li>\n<p><code>'evaluated'</code>: The module has been successfully evaluated.</p>\n</li>\n<li>\n<p><code>'errored'</code>: The module has been evaluated, but an exception was thrown.</p>\n</li>\n</ul>\n<p>Other than <code>'errored'</code>, this status string corresponds to the specification's\n<a href=\"https://tc39.es/ecma262/#sec-cyclic-module-records\">Cyclic Module Record</a>'s <code>[[Status]]</code> field. <code>'errored'</code> corresponds to\n<code>'evaluated'</code> in the specification, but with <code>[[EvaluationError]]</code> set to a\nvalue that is not <code>undefined</code>.</p>"
            }
          ],
          "methods": [
            {
              "textRaw": "`module.evaluate([options])`",
              "type": "method",
              "name": "evaluate",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Promise} Fulfills with `undefined` upon success.",
                    "name": "return",
                    "type": "Promise",
                    "desc": "Fulfills with `undefined` upon success."
                  },
                  "params": [
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`timeout` {integer} Specifies the number of milliseconds to evaluate before terminating execution. If execution is interrupted, an [`Error`][] will be thrown. This value must be a strictly positive integer.",
                          "name": "timeout",
                          "type": "integer",
                          "desc": "Specifies the number of milliseconds to evaluate before terminating execution. If execution is interrupted, an [`Error`][] will be thrown. This value must be a strictly positive integer."
                        },
                        {
                          "textRaw": "`breakOnSigint` {boolean} If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that. **Default:** `false`.",
                          "name": "breakOnSigint",
                          "type": "boolean",
                          "default": "`false`",
                          "desc": "If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>Evaluate the module.</p>\n<p>This must be called after the module has been linked; otherwise it will reject.\nIt could be called also when the module has already been evaluated, in which\ncase it will either do nothing if the initial evaluation ended in success\n(<code>module.status</code> is <code>'evaluated'</code>) or it will re-throw the exception that the\ninitial evaluation resulted in (<code>module.status</code> is <code>'errored'</code>).</p>\n<p>This method cannot be called while the module is being evaluated\n(<code>module.status</code> is <code>'evaluating'</code>).</p>\n<p>Corresponds to the <a href=\"https://tc39.es/ecma262/#sec-moduleevaluation\">Evaluate() concrete method</a> field of <a href=\"https://tc39.es/ecma262/#sec-cyclic-module-records\">Cyclic Module\nRecord</a>s in the ECMAScript specification.</p>"
            },
            {
              "textRaw": "`module.link(linker)`",
              "type": "method",
              "name": "link",
              "meta": {
                "changes": [
                  {
                    "version": "v20.10.0",
                    "pr-url": "https://github.com/nodejs/node/pull/50141",
                    "description": "The option `extra.assert` is renamed to `extra.attributes`. The former name is still provided for backward compatibility."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Promise}",
                    "name": "return",
                    "type": "Promise"
                  },
                  "params": [
                    {
                      "textRaw": "`linker` {Function}",
                      "name": "linker",
                      "type": "Function",
                      "options": [
                        {
                          "textRaw": "`specifier` {string} The specifier of the requested module:```mjs import foo from 'foo'; // ^^^^^ the module specifier ```",
                          "name": "specifier",
                          "type": "string",
                          "desc": "The specifier of the requested module:```mjs import foo from 'foo'; // ^^^^^ the module specifier ```"
                        },
                        {
                          "textRaw": "`referencingModule` {vm.Module} The `Module` object `link()` is called on.",
                          "name": "referencingModule",
                          "type": "vm.Module",
                          "desc": "The `Module` object `link()` is called on."
                        },
                        {
                          "textRaw": "`extra` {Object}",
                          "name": "extra",
                          "type": "Object",
                          "options": [
                            {
                              "textRaw": "`attributes` {Object} The data from the attribute:```mjs import foo from 'foo' with { name: 'value' }; // ^^^^^^^^^^^^^^^^^ the attribute ```Per ECMA-262, hosts are expected to trigger an error if an unsupported attribute is present.",
                              "name": "attributes",
                              "type": "Object",
                              "desc": "The data from the attribute:```mjs import foo from 'foo' with { name: 'value' }; // ^^^^^^^^^^^^^^^^^ the attribute ```Per ECMA-262, hosts are expected to trigger an error if an unsupported attribute is present."
                            },
                            {
                              "textRaw": "`assert` {Object} Alias for `extra.attributes`.",
                              "name": "assert",
                              "type": "Object",
                              "desc": "Alias for `extra.attributes`."
                            }
                          ]
                        },
                        {
                          "textRaw": "Returns: {vm.Module|Promise}",
                          "name": "return",
                          "type": "vm.Module|Promise"
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>Link module dependencies. This method must be called before evaluation, and\ncan only be called once per module.</p>\n<p>The function is expected to return a <code>Module</code> object or a <code>Promise</code> that\neventually resolves to a <code>Module</code> object. The returned <code>Module</code> must satisfy the\nfollowing two invariants:</p>\n<ul>\n<li>It must belong to the same context as the parent <code>Module</code>.</li>\n<li>Its <code>status</code> must not be <code>'errored'</code>.</li>\n</ul>\n<p>If the returned <code>Module</code>'s <code>status</code> is <code>'unlinked'</code>, this method will be\nrecursively called on the returned <code>Module</code> with the same provided <code>linker</code>\nfunction.</p>\n<p><code>link()</code> returns a <code>Promise</code> that will either get resolved when all linking\ninstances resolve to a valid <code>Module</code>, or rejected if the linker function either\nthrows an exception or returns an invalid <code>Module</code>.</p>\n<p>The linker function roughly corresponds to the implementation-defined\n<a href=\"https://tc39.es/ecma262/#sec-hostresolveimportedmodule\">HostResolveImportedModule</a> abstract operation in the ECMAScript\nspecification, with a few key differences:</p>\n<ul>\n<li>The linker function is allowed to be asynchronous while\n<a href=\"https://tc39.es/ecma262/#sec-hostresolveimportedmodule\">HostResolveImportedModule</a> is synchronous.</li>\n</ul>\n<p>The actual <a href=\"https://tc39.es/ecma262/#sec-hostresolveimportedmodule\">HostResolveImportedModule</a> implementation used during module\nlinking is one that returns the modules linked during linking. Since at\nthat point all modules would have been fully linked already, the\n<a href=\"https://tc39.es/ecma262/#sec-hostresolveimportedmodule\">HostResolveImportedModule</a> implementation is fully synchronous per\nspecification.</p>\n<p>Corresponds to the <a href=\"https://tc39.es/ecma262/#sec-moduledeclarationlinking\">Link() concrete method</a> field of <a href=\"https://tc39.es/ecma262/#sec-cyclic-module-records\">Cyclic Module\nRecord</a>s in the ECMAScript specification.</p>"
            }
          ]
        },
        {
          "textRaw": "Class: `vm.SourceTextModule`",
          "type": "class",
          "name": "vm.SourceTextModule",
          "meta": {
            "added": [
              "v9.6.0"
            ],
            "changes": []
          },
          "stability": 1,
          "stabilityText": "Experimental",
          "desc": "<p>This feature is only available with the <code>--experimental-vm-modules</code> command\nflag enabled.</p>\n<ul>\n<li>Extends: <a href=\"vm.html#class-vmmodule\" class=\"type\">&lt;vm.Module&gt;</a></li>\n</ul>\n<p>The <code>vm.SourceTextModule</code> class provides the <a href=\"https://tc39.es/ecma262/#sec-source-text-module-records\">Source Text Module Record</a> as\ndefined in the ECMAScript specification.</p>",
          "methods": [
            {
              "textRaw": "`sourceTextModule.createCachedData()`",
              "type": "method",
              "name": "createCachedData",
              "meta": {
                "added": [
                  "v13.7.0",
                  "v12.17.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer}",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": []
                }
              ],
              "desc": "<p>Creates a code cache that can be used with the <code>SourceTextModule</code> constructor's\n<code>cachedData</code> option. Returns a <code>Buffer</code>. This method may be called any number\nof times before the module has been evaluated.</p>\n<p>The code cache of the <code>SourceTextModule</code> doesn't contain any JavaScript\nobservable states. The code cache is safe to be saved along side the script\nsource and used to construct new <code>SourceTextModule</code> instances multiple times.</p>\n<p>Functions in the <code>SourceTextModule</code> source can be marked as lazily compiled\nand they are not compiled at construction of the <code>SourceTextModule</code>. These\nfunctions are going to be compiled when they are invoked the first time. The\ncode cache serializes the metadata that V8 currently knows about the\n<code>SourceTextModule</code> that it can use to speed up future compilations.</p>\n<pre><code class=\"language-js\">// Create an initial module\nconst module = new vm.SourceTextModule('const a = 1;');\n\n// Create cached data from this module\nconst cachedData = module.createCachedData();\n\n// Create a new module using the cached data. The code must be the same.\nconst module2 = new vm.SourceTextModule('const a = 1;', { cachedData });\n</code></pre>"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`code` {string} JavaScript Module code to parse",
                  "name": "code",
                  "type": "string",
                  "desc": "JavaScript Module code to parse"
                },
                {
                  "textRaw": "`options`",
                  "name": "options",
                  "options": [
                    {
                      "textRaw": "`identifier` {string} String used in stack traces. **Default:** `'vm:module(i)'` where `i` is a context-specific ascending index.",
                      "name": "identifier",
                      "type": "string",
                      "default": "`'vm:module(i)'` where `i` is a context-specific ascending index",
                      "desc": "String used in stack traces."
                    },
                    {
                      "textRaw": "`cachedData` {Buffer|TypedArray|DataView} Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source. The `code` must be the same as the module from which this `cachedData` was created.",
                      "name": "cachedData",
                      "type": "Buffer|TypedArray|DataView",
                      "desc": "Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source. The `code` must be the same as the module from which this `cachedData` was created."
                    },
                    {
                      "textRaw": "`context` {Object} The [contextified][] object as returned by the `vm.createContext()` method, to compile and evaluate this `Module` in. If no context is specified, the module is evaluated in the current execution context.",
                      "name": "context",
                      "type": "Object",
                      "desc": "The [contextified][] object as returned by the `vm.createContext()` method, to compile and evaluate this `Module` in. If no context is specified, the module is evaluated in the current execution context."
                    },
                    {
                      "textRaw": "`lineOffset` {integer} Specifies the line number offset that is displayed in stack traces produced by this `Module`. **Default:** `0`.",
                      "name": "lineOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Specifies the line number offset that is displayed in stack traces produced by this `Module`."
                    },
                    {
                      "textRaw": "`columnOffset` {integer} Specifies the first-line column number offset that is displayed in stack traces produced by this `Module`. **Default:** `0`.",
                      "name": "columnOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Specifies the first-line column number offset that is displayed in stack traces produced by this `Module`."
                    },
                    {
                      "textRaw": "`initializeImportMeta` {Function} Called during evaluation of this `Module` to initialize the `import.meta`.",
                      "name": "initializeImportMeta",
                      "type": "Function",
                      "desc": "Called during evaluation of this `Module` to initialize the `import.meta`.",
                      "options": [
                        {
                          "textRaw": "`meta` {import.meta}",
                          "name": "meta",
                          "type": "import.meta"
                        },
                        {
                          "textRaw": "`module` {vm.SourceTextModule}",
                          "name": "module",
                          "type": "vm.SourceTextModule"
                        }
                      ]
                    },
                    {
                      "textRaw": "`importModuleDynamically` {Function} Used to specify the how the modules should be loaded during the evaluation of this module when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][].",
                      "name": "importModuleDynamically",
                      "type": "Function",
                      "desc": "Used to specify the how the modules should be loaded during the evaluation of this module when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][]."
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a new <code>SourceTextModule</code> instance.</p>\n<p>Properties assigned to the <code>import.meta</code> object that are objects may\nallow the module to access information outside the specified <code>context</code>. Use\n<code>vm.runInContext()</code> to create objects in a specific context.</p>\n<pre><code class=\"language-mjs\">import vm from 'node:vm';\n\nconst contextifiedObject = vm.createContext({ secret: 42 });\n\nconst module = new vm.SourceTextModule(\n  'Object.getPrototypeOf(import.meta.prop).secret = secret;',\n  {\n    initializeImportMeta(meta) {\n      // Note: this object is created in the top context. As such,\n      // Object.getPrototypeOf(import.meta.prop) points to the\n      // Object.prototype in the top context rather than that in\n      // the contextified object.\n      meta.prop = {};\n    },\n  });\n// Since module has no dependencies, the linker function will never be called.\nawait module.link(() => {});\nawait module.evaluate();\n\n// Now, Object.prototype.secret will be equal to 42.\n//\n// To fix this problem, replace\n//     meta.prop = {};\n// above with\n//     meta.prop = vm.runInContext('{}', contextifiedObject);\n</code></pre>\n<pre><code class=\"language-cjs\">const vm = require('node:vm');\nconst contextifiedObject = vm.createContext({ secret: 42 });\n(async () => {\n  const module = new vm.SourceTextModule(\n    'Object.getPrototypeOf(import.meta.prop).secret = secret;',\n    {\n      initializeImportMeta(meta) {\n        // Note: this object is created in the top context. As such,\n        // Object.getPrototypeOf(import.meta.prop) points to the\n        // Object.prototype in the top context rather than that in\n        // the contextified object.\n        meta.prop = {};\n      },\n    });\n  // Since module has no dependencies, the linker function will never be called.\n  await module.link(() => {});\n  await module.evaluate();\n  // Now, Object.prototype.secret will be equal to 42.\n  //\n  // To fix this problem, replace\n  //     meta.prop = {};\n  // above with\n  //     meta.prop = vm.runInContext('{}', contextifiedObject);\n})();\n</code></pre>"
            }
          ]
        },
        {
          "textRaw": "Class: `vm.SyntheticModule`",
          "type": "class",
          "name": "vm.SyntheticModule",
          "meta": {
            "added": [
              "v13.0.0",
              "v12.16.0"
            ],
            "changes": []
          },
          "stability": 1,
          "stabilityText": "Experimental",
          "desc": "<p>This feature is only available with the <code>--experimental-vm-modules</code> command\nflag enabled.</p>\n<ul>\n<li>Extends: <a href=\"vm.html#class-vmmodule\" class=\"type\">&lt;vm.Module&gt;</a></li>\n</ul>\n<p>The <code>vm.SyntheticModule</code> class provides the <a href=\"https://heycam.github.io/webidl/#synthetic-module-records\">Synthetic Module Record</a> as\ndefined in the WebIDL specification. The purpose of synthetic modules is to\nprovide a generic interface for exposing non-JavaScript sources to ECMAScript\nmodule graphs.</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nconst source = '{ \"a\": 1 }';\nconst module = new vm.SyntheticModule(['default'], function() {\n  const obj = JSON.parse(source);\n  this.setExport('default', obj);\n});\n\n// Use `module` in linking...\n</code></pre>",
          "methods": [
            {
              "textRaw": "`syntheticModule.setExport(name, value)`",
              "type": "method",
              "name": "setExport",
              "meta": {
                "added": [
                  "v13.0.0",
                  "v12.16.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`name` {string} Name of the export to set.",
                      "name": "name",
                      "type": "string",
                      "desc": "Name of the export to set."
                    },
                    {
                      "textRaw": "`value` {any} The value to set the export to.",
                      "name": "value",
                      "type": "any",
                      "desc": "The value to set the export to."
                    }
                  ]
                }
              ],
              "desc": "<p>This method is used after the module is linked to set the values of exports. If\nit is called before the module is linked, an <a href=\"errors.html#err_vm_module_status\"><code>ERR_VM_MODULE_STATUS</code></a> error\nwill be thrown.</p>\n<pre><code class=\"language-mjs\">import vm from 'node:vm';\n\nconst m = new vm.SyntheticModule(['x'], () => {\n  m.setExport('x', 1);\n});\n\nawait m.link(() => {});\nawait m.evaluate();\n\nassert.strictEqual(m.namespace.x, 1);\n</code></pre>\n<pre><code class=\"language-cjs\">const vm = require('node:vm');\n(async () => {\n  const m = new vm.SyntheticModule(['x'], () => {\n    m.setExport('x', 1);\n  });\n  await m.link(() => {});\n  await m.evaluate();\n  assert.strictEqual(m.namespace.x, 1);\n})();\n</code></pre>"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`exportNames` {string\\[]} Array of names that will be exported from the module.",
                  "name": "exportNames",
                  "type": "string\\[]",
                  "desc": "Array of names that will be exported from the module."
                },
                {
                  "textRaw": "`evaluateCallback` {Function} Called when the module is evaluated.",
                  "name": "evaluateCallback",
                  "type": "Function",
                  "desc": "Called when the module is evaluated."
                },
                {
                  "textRaw": "`options`",
                  "name": "options",
                  "options": [
                    {
                      "textRaw": "`identifier` {string} String used in stack traces. **Default:** `'vm:module(i)'` where `i` is a context-specific ascending index.",
                      "name": "identifier",
                      "type": "string",
                      "default": "`'vm:module(i)'` where `i` is a context-specific ascending index",
                      "desc": "String used in stack traces."
                    },
                    {
                      "textRaw": "`context` {Object} The [contextified][] object as returned by the `vm.createContext()` method, to compile and evaluate this `Module` in.",
                      "name": "context",
                      "type": "Object",
                      "desc": "The [contextified][] object as returned by the `vm.createContext()` method, to compile and evaluate this `Module` in."
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a new <code>SyntheticModule</code> instance.</p>\n<p>Objects assigned to the exports of this instance may allow importers of\nthe module to access information outside the specified <code>context</code>. Use\n<code>vm.runInContext()</code> to create objects in a specific context.</p>"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "`vm.compileFunction(code[, params[, options]])`",
          "type": "method",
          "name": "compileFunction",
          "meta": {
            "added": [
              "v10.10.0"
            ],
            "changes": [
              {
                "version": [
                  "v20.12.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/51244",
                "description": "Added support for `vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`."
              },
              {
                "version": [
                  "v19.6.0",
                  "v18.15.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/46320",
                "description": "The return value now includes `cachedDataRejected` with the same semantics as the `vm.Script` version if the `cachedData` option was passed."
              },
              {
                "version": [
                  "v17.0.0",
                  "v16.12.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/40249",
                "description": "Added support for import attributes to the `importModuleDynamically` parameter."
              },
              {
                "version": "v15.9.0",
                "pr-url": "https://github.com/nodejs/node/pull/35431",
                "description": "Added `importModuleDynamically` option again."
              },
              {
                "version": "v14.3.0",
                "pr-url": "https://github.com/nodejs/node/pull/33364",
                "description": "Removal of `importModuleDynamically` due to compatibility issues."
              },
              {
                "version": [
                  "v14.1.0",
                  "v13.14.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/32985",
                "description": "The `importModuleDynamically` option is now supported."
              }
            ]
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {Function}",
                "name": "return",
                "type": "Function"
              },
              "params": [
                {
                  "textRaw": "`code` {string} The body of the function to compile.",
                  "name": "code",
                  "type": "string",
                  "desc": "The body of the function to compile."
                },
                {
                  "textRaw": "`params` {string\\[]} An array of strings containing all parameters for the function.",
                  "name": "params",
                  "type": "string\\[]",
                  "desc": "An array of strings containing all parameters for the function."
                },
                {
                  "textRaw": "`options` {Object}",
                  "name": "options",
                  "type": "Object",
                  "options": [
                    {
                      "textRaw": "`filename` {string} Specifies the filename used in stack traces produced by this script. **Default:** `''`.",
                      "name": "filename",
                      "type": "string",
                      "default": "`''`",
                      "desc": "Specifies the filename used in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`lineOffset` {number} Specifies the line number offset that is displayed in stack traces produced by this script. **Default:** `0`.",
                      "name": "lineOffset",
                      "type": "number",
                      "default": "`0`",
                      "desc": "Specifies the line number offset that is displayed in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`columnOffset` {number} Specifies the first-line column number offset that is displayed in stack traces produced by this script. **Default:** `0`.",
                      "name": "columnOffset",
                      "type": "number",
                      "default": "`0`",
                      "desc": "Specifies the first-line column number offset that is displayed in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`cachedData` {Buffer|TypedArray|DataView} Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source. This must be produced by a prior call to [`vm.compileFunction()`][] with the same `code` and `params`.",
                      "name": "cachedData",
                      "type": "Buffer|TypedArray|DataView",
                      "desc": "Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source. This must be produced by a prior call to [`vm.compileFunction()`][] with the same `code` and `params`."
                    },
                    {
                      "textRaw": "`produceCachedData` {boolean} Specifies whether to produce new cache data. **Default:** `false`.",
                      "name": "produceCachedData",
                      "type": "boolean",
                      "default": "`false`",
                      "desc": "Specifies whether to produce new cache data."
                    },
                    {
                      "textRaw": "`parsingContext` {Object} The [contextified][] object in which the said function should be compiled in.",
                      "name": "parsingContext",
                      "type": "Object",
                      "desc": "The [contextified][] object in which the said function should be compiled in."
                    },
                    {
                      "textRaw": "`contextExtensions` {Object\\[]} An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling. **Default:** `[]`.",
                      "name": "contextExtensions",
                      "type": "Object\\[]",
                      "default": "`[]`",
                      "desc": "An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling."
                    }
                  ]
                },
                {
                  "textRaw": "`importModuleDynamically` {Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER} Used to specify the how the modules should be loaded during the evaluation of this function when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][].",
                  "name": "importModuleDynamically",
                  "type": "Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER",
                  "desc": "Used to specify the how the modules should be loaded during the evaluation of this function when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][]."
                }
              ]
            }
          ],
          "desc": "<p>Compiles the given code into the provided context (if no context is\nsupplied, the current context is used), and returns it wrapped inside a\nfunction with the given <code>params</code>.</p>"
        },
        {
          "textRaw": "`vm.createContext([contextObject[, options]])`",
          "type": "method",
          "name": "createContext",
          "meta": {
            "added": [
              "v0.3.1"
            ],
            "changes": [
              {
                "version": [
                  "v20.18.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/54394",
                "description": "The `contextObject` argument now accepts `vm.constants.DONT_CONTEXTIFY`."
              },
              {
                "version": [
                  "v20.12.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/51244",
                "description": "Added support for `vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`."
              },
              {
                "version": [
                  "v20.11.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/50360",
                "description": "The `importModuleDynamically` option is supported now."
              },
              {
                "version": "v14.6.0",
                "pr-url": "https://github.com/nodejs/node/pull/34023",
                "description": "The `microtaskMode` option is supported now."
              },
              {
                "version": "v10.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/19398",
                "description": "The first argument can no longer be a function."
              },
              {
                "version": "v10.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/19016",
                "description": "The `codeGeneration` option is supported now."
              }
            ]
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {Object} contextified object.",
                "name": "return",
                "type": "Object",
                "desc": "contextified object."
              },
              "params": [
                {
                  "textRaw": "`contextObject` {Object|vm.constants.DONT\\_CONTEXTIFY|undefined} Either [`vm.constants.DONT_CONTEXTIFY`][] or an object that will be [contextified][]. If `undefined`, an empty contextified object will be created for backwards compatibility.",
                  "name": "contextObject",
                  "type": "Object|vm.constants.DONT\\_CONTEXTIFY|undefined",
                  "desc": "Either [`vm.constants.DONT_CONTEXTIFY`][] or an object that will be [contextified][]. If `undefined`, an empty contextified object will be created for backwards compatibility."
                },
                {
                  "textRaw": "`options` {Object}",
                  "name": "options",
                  "type": "Object",
                  "options": [
                    {
                      "textRaw": "`name` {string} Human-readable name of the newly created context. **Default:** `'VM Context i'`, where `i` is an ascending numerical index of the created context.",
                      "name": "name",
                      "type": "string",
                      "default": "`'VM Context i'`, where `i` is an ascending numerical index of the created context",
                      "desc": "Human-readable name of the newly created context."
                    },
                    {
                      "textRaw": "`origin` {string} [Origin][origin] corresponding to the newly created context for display purposes. The origin should be formatted like a URL, but with only the scheme, host, and port (if necessary), like the value of the [`url.origin`][] property of a [`URL`][] object. Most notably, this string should omit the trailing slash, as that denotes a path. **Default:** `''`.",
                      "name": "origin",
                      "type": "string",
                      "default": "`''`",
                      "desc": "[Origin][origin] corresponding to the newly created context for display purposes. The origin should be formatted like a URL, but with only the scheme, host, and port (if necessary), like the value of the [`url.origin`][] property of a [`URL`][] object. Most notably, this string should omit the trailing slash, as that denotes a path."
                    },
                    {
                      "textRaw": "`codeGeneration` {Object}",
                      "name": "codeGeneration",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`strings` {boolean} If set to false any calls to `eval` or function constructors (`Function`, `GeneratorFunction`, etc) will throw an `EvalError`. **Default:** `true`.",
                          "name": "strings",
                          "type": "boolean",
                          "default": "`true`",
                          "desc": "If set to false any calls to `eval` or function constructors (`Function`, `GeneratorFunction`, etc) will throw an `EvalError`."
                        },
                        {
                          "textRaw": "`wasm` {boolean} If set to false any attempt to compile a WebAssembly module will throw a `WebAssembly.CompileError`. **Default:** `true`.",
                          "name": "wasm",
                          "type": "boolean",
                          "default": "`true`",
                          "desc": "If set to false any attempt to compile a WebAssembly module will throw a `WebAssembly.CompileError`."
                        }
                      ]
                    },
                    {
                      "textRaw": "`microtaskMode` {string} If set to `afterEvaluate`, microtasks (tasks scheduled through `Promise`s and `async function`s) will be run immediately after a script has run through [`script.runInContext()`][]. They are included in the `timeout` and `breakOnSigint` scopes in that case.",
                      "name": "microtaskMode",
                      "type": "string",
                      "desc": "If set to `afterEvaluate`, microtasks (tasks scheduled through `Promise`s and `async function`s) will be run immediately after a script has run through [`script.runInContext()`][]. They are included in the `timeout` and `breakOnSigint` scopes in that case."
                    },
                    {
                      "textRaw": "`importModuleDynamically` {Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER} Used to specify the how the modules should be loaded when `import()` is called in this context without a referrer script or module. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][].",
                      "name": "importModuleDynamically",
                      "type": "Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER",
                      "desc": "Used to specify the how the modules should be loaded when `import()` is called in this context without a referrer script or module. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][]."
                    }
                  ]
                }
              ]
            }
          ],
          "desc": "<p>If the given <code>contextObject</code> is an object, the <code>vm.createContext()</code> method will <a href=\"#what-does-it-mean-to-contextify-an-object\">prepare that\nobject</a> and return a reference to it so that it can be used in\ncalls to <a href=\"#vmrunincontextcode-contextifiedobject-options\"><code>vm.runInContext()</code></a> or <a href=\"#scriptrunincontextcontextifiedobject-options\"><code>script.runInContext()</code></a>. Inside such\nscripts, the global object will be wrapped by the <code>contextObject</code>, retaining all of its\nexisting properties but also having the built-in objects and functions any\nstandard <a href=\"https://es5.github.io/#x15.1\">global object</a> has. Outside of scripts run by the vm module, global\nvariables will remain unchanged.</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nglobal.globalVar = 3;\n\nconst context = { globalVar: 1 };\nvm.createContext(context);\n\nvm.runInContext('globalVar *= 2;', context);\n\nconsole.log(context);\n// Prints: { globalVar: 2 }\n\nconsole.log(global.globalVar);\n// Prints: 3\n</code></pre>\n<p>If <code>contextObject</code> is omitted (or passed explicitly as <code>undefined</code>), a new,\nempty <a href=\"#what-does-it-mean-to-contextify-an-object\">contextified</a> object will be returned.</p>\n<p>When the global object in the newly created context is <a href=\"#what-does-it-mean-to-contextify-an-object\">contextified</a>, it has some quirks\ncompared to ordinary global objects. For example, it cannot be frozen. To create a context\nwithout the contextifying quirks, pass <a href=\"#vmconstantsdont_contextify\"><code>vm.constants.DONT_CONTEXTIFY</code></a> as the <code>contextObject</code>\nargument. See the documentation of <a href=\"#vmconstantsdont_contextify\"><code>vm.constants.DONT_CONTEXTIFY</code></a> for details.</p>\n<p>The <code>vm.createContext()</code> method is primarily useful for creating a single\ncontext that can be used to run multiple scripts. For instance, if emulating a\nweb browser, the method can be used to create a single context representing a\nwindow's global object, then run all <code>&#x3C;script></code> tags together within that\ncontext.</p>\n<p>The provided <code>name</code> and <code>origin</code> of the context are made visible through the\nInspector API.</p>"
        },
        {
          "textRaw": "`vm.isContext(object)`",
          "type": "method",
          "name": "isContext",
          "meta": {
            "added": [
              "v0.11.7"
            ],
            "changes": []
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {boolean}",
                "name": "return",
                "type": "boolean"
              },
              "params": [
                {
                  "textRaw": "`object` {Object}",
                  "name": "object",
                  "type": "Object"
                }
              ]
            }
          ],
          "desc": "<p>Returns <code>true</code> if the given <code>object</code> object has been <a href=\"#what-does-it-mean-to-contextify-an-object\">contextified</a> using\n<a href=\"#vmcreatecontextcontextobject-options\"><code>vm.createContext()</code></a>, or if it's the global object of a context created\nusing <a href=\"#vmconstantsdont_contextify\"><code>vm.constants.DONT_CONTEXTIFY</code></a>.</p>"
        },
        {
          "textRaw": "`vm.measureMemory([options])`",
          "type": "method",
          "name": "measureMemory",
          "meta": {
            "added": [
              "v13.10.0"
            ],
            "changes": []
          },
          "stability": 1,
          "stabilityText": "Experimental",
          "signatures": [
            {
              "params": []
            }
          ],
          "desc": "<p>Measure the memory known to V8 and used by all contexts known to the\ncurrent V8 isolate, or the main context.</p>\n<ul>\n<li><code>options</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\" class=\"type\">&lt;Object&gt;</a> Optional.\n<ul>\n<li><code>mode</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> Either <code>'summary'</code> or <code>'detailed'</code>. In summary mode,\nonly the memory measured for the main context will be returned. In\ndetailed mode, the memory measured for all contexts known to the\ncurrent V8 isolate will be returned.\n<strong>Default:</strong> <code>'summary'</code></li>\n<li><code>execution</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> Either <code>'default'</code> or <code>'eager'</code>. With default\nexecution, the promise will not resolve until after the next scheduled\ngarbage collection starts, which may take a while (or never if the program\nexits before the next GC). With eager execution, the GC will be started\nright away to measure the memory.\n<strong>Default:</strong> <code>'default'</code></li>\n</ul>\n</li>\n<li>Returns: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" class=\"type\">&lt;Promise&gt;</a> If the memory is successfully measured, the promise will\nresolve with an object containing information about the memory usage.\nOtherwise it will be rejected with an <code>ERR_CONTEXT_NOT_INITIALIZED</code> error.</li>\n</ul>\n<p>The format of the object that the returned Promise may resolve with is\nspecific to the V8 engine and may change from one version of V8 to the next.</p>\n<p>The returned result is different from the statistics returned by\n<code>v8.getHeapSpaceStatistics()</code> in that <code>vm.measureMemory()</code> measure the\nmemory reachable by each V8 specific contexts in the current instance of\nthe V8 engine, while the result of <code>v8.getHeapSpaceStatistics()</code> measure\nthe memory occupied by each heap space in the current V8 instance.</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n// Measure the memory used by the main context.\nvm.measureMemory({ mode: 'summary' })\n  // This is the same as vm.measureMemory()\n  .then((result) => {\n    // The current format is:\n    // {\n    //   total: {\n    //      jsMemoryEstimate: 2418479, jsMemoryRange: [ 2418479, 2745799 ]\n    //    }\n    // }\n    console.log(result);\n  });\n\nconst context = vm.createContext({ a: 1 });\nvm.measureMemory({ mode: 'detailed', execution: 'eager' })\n  .then((result) => {\n    // Reference the context here so that it won't be GC'ed\n    // until the measurement is complete.\n    console.log(context.a);\n    // {\n    //   total: {\n    //     jsMemoryEstimate: 2574732,\n    //     jsMemoryRange: [ 2574732, 2904372 ]\n    //   },\n    //   current: {\n    //     jsMemoryEstimate: 2438996,\n    //     jsMemoryRange: [ 2438996, 2768636 ]\n    //   },\n    //   other: [\n    //     {\n    //       jsMemoryEstimate: 135736,\n    //       jsMemoryRange: [ 135736, 465376 ]\n    //     }\n    //   ]\n    // }\n    console.log(result);\n  });\n</code></pre>"
        },
        {
          "textRaw": "`vm.runInContext(code, contextifiedObject[, options])`",
          "type": "method",
          "name": "runInContext",
          "meta": {
            "added": [
              "v0.3.1"
            ],
            "changes": [
              {
                "version": [
                  "v20.12.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/51244",
                "description": "Added support for `vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`."
              },
              {
                "version": [
                  "v17.0.0",
                  "v16.12.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/40249",
                "description": "Added support for import attributes to the `importModuleDynamically` parameter."
              },
              {
                "version": "v6.3.0",
                "pr-url": "https://github.com/nodejs/node/pull/6635",
                "description": "The `breakOnSigint` option is supported now."
              }
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`code` {string} The JavaScript code to compile and run.",
                  "name": "code",
                  "type": "string",
                  "desc": "The JavaScript code to compile and run."
                },
                {
                  "textRaw": "`contextifiedObject` {Object} The [contextified][] object that will be used as the `global` when the `code` is compiled and run.",
                  "name": "contextifiedObject",
                  "type": "Object",
                  "desc": "The [contextified][] object that will be used as the `global` when the `code` is compiled and run."
                },
                {
                  "textRaw": "`options` {Object|string}",
                  "name": "options",
                  "type": "Object|string",
                  "options": [
                    {
                      "textRaw": "`filename` {string} Specifies the filename used in stack traces produced by this script. **Default:** `'evalmachine.<anonymous>'`.",
                      "name": "filename",
                      "type": "string",
                      "default": "`'evalmachine.<anonymous>'`",
                      "desc": "Specifies the filename used in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`lineOffset` {number} Specifies the line number offset that is displayed in stack traces produced by this script. **Default:** `0`.",
                      "name": "lineOffset",
                      "type": "number",
                      "default": "`0`",
                      "desc": "Specifies the line number offset that is displayed in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`columnOffset` {number} Specifies the first-line column number offset that is displayed in stack traces produced by this script. **Default:** `0`.",
                      "name": "columnOffset",
                      "type": "number",
                      "default": "`0`",
                      "desc": "Specifies the first-line column number offset that is displayed in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`displayErrors` {boolean} When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace. **Default:** `true`.",
                      "name": "displayErrors",
                      "type": "boolean",
                      "default": "`true`",
                      "desc": "When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace."
                    },
                    {
                      "textRaw": "`timeout` {integer} Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer.",
                      "name": "timeout",
                      "type": "integer",
                      "desc": "Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer."
                    },
                    {
                      "textRaw": "`breakOnSigint` {boolean} If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that. **Default:** `false`.",
                      "name": "breakOnSigint",
                      "type": "boolean",
                      "default": "`false`",
                      "desc": "If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that."
                    },
                    {
                      "textRaw": "`cachedData` {Buffer|TypedArray|DataView} Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source.",
                      "name": "cachedData",
                      "type": "Buffer|TypedArray|DataView",
                      "desc": "Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source."
                    },
                    {
                      "textRaw": "`importModuleDynamically` {Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER} Used to specify the how the modules should be loaded during the evaluation of this script when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][].",
                      "name": "importModuleDynamically",
                      "type": "Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER",
                      "desc": "Used to specify the how the modules should be loaded during the evaluation of this script when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][]."
                    }
                  ]
                }
              ]
            }
          ],
          "desc": "<p>The <code>vm.runInContext()</code> method compiles <code>code</code>, runs it within the context of\nthe <code>contextifiedObject</code>, then returns the result. Running code does not have\naccess to the local scope. The <code>contextifiedObject</code> object <em>must</em> have been\npreviously <a href=\"#what-does-it-mean-to-contextify-an-object\">contextified</a> using the <a href=\"#vmcreatecontextcontextobject-options\"><code>vm.createContext()</code></a> method.</p>\n<p>If <code>options</code> is a string, then it specifies the filename.</p>\n<p>The following example compiles and executes different scripts using a single\n<a href=\"#what-does-it-mean-to-contextify-an-object\">contextified</a> object:</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nconst contextObject = { globalVar: 1 };\nvm.createContext(contextObject);\n\nfor (let i = 0; i &#x3C; 10; ++i) {\n  vm.runInContext('globalVar *= 2;', contextObject);\n}\nconsole.log(contextObject);\n// Prints: { globalVar: 1024 }\n</code></pre>"
        },
        {
          "textRaw": "`vm.runInNewContext(code[, contextObject[, options]])`",
          "type": "method",
          "name": "runInNewContext",
          "meta": {
            "added": [
              "v0.3.1"
            ],
            "changes": [
              {
                "version": [
                  "v20.18.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/54394",
                "description": "The `contextObject` argument now accepts `vm.constants.DONT_CONTEXTIFY`."
              },
              {
                "version": [
                  "v20.12.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/51244",
                "description": "Added support for `vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`."
              },
              {
                "version": [
                  "v17.0.0",
                  "v16.12.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/40249",
                "description": "Added support for import attributes to the `importModuleDynamically` parameter."
              },
              {
                "version": "v14.6.0",
                "pr-url": "https://github.com/nodejs/node/pull/34023",
                "description": "The `microtaskMode` option is supported now."
              },
              {
                "version": "v10.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/19016",
                "description": "The `contextCodeGeneration` option is supported now."
              },
              {
                "version": "v6.3.0",
                "pr-url": "https://github.com/nodejs/node/pull/6635",
                "description": "The `breakOnSigint` option is supported now."
              }
            ]
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {any} the result of the very last statement executed in the script.",
                "name": "return",
                "type": "any",
                "desc": "the result of the very last statement executed in the script."
              },
              "params": [
                {
                  "textRaw": "`code` {string} The JavaScript code to compile and run.",
                  "name": "code",
                  "type": "string",
                  "desc": "The JavaScript code to compile and run."
                },
                {
                  "textRaw": "`contextObject` {Object|vm.constants.DONT\\_CONTEXTIFY|undefined} Either [`vm.constants.DONT_CONTEXTIFY`][] or an object that will be [contextified][]. If `undefined`, an empty contextified object will be created for backwards compatibility.",
                  "name": "contextObject",
                  "type": "Object|vm.constants.DONT\\_CONTEXTIFY|undefined",
                  "desc": "Either [`vm.constants.DONT_CONTEXTIFY`][] or an object that will be [contextified][]. If `undefined`, an empty contextified object will be created for backwards compatibility."
                },
                {
                  "textRaw": "`options` {Object|string}",
                  "name": "options",
                  "type": "Object|string",
                  "options": [
                    {
                      "textRaw": "`filename` {string} Specifies the filename used in stack traces produced by this script. **Default:** `'evalmachine.<anonymous>'`.",
                      "name": "filename",
                      "type": "string",
                      "default": "`'evalmachine.<anonymous>'`",
                      "desc": "Specifies the filename used in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`lineOffset` {number} Specifies the line number offset that is displayed in stack traces produced by this script. **Default:** `0`.",
                      "name": "lineOffset",
                      "type": "number",
                      "default": "`0`",
                      "desc": "Specifies the line number offset that is displayed in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`columnOffset` {number} Specifies the first-line column number offset that is displayed in stack traces produced by this script. **Default:** `0`.",
                      "name": "columnOffset",
                      "type": "number",
                      "default": "`0`",
                      "desc": "Specifies the first-line column number offset that is displayed in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`displayErrors` {boolean} When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace. **Default:** `true`.",
                      "name": "displayErrors",
                      "type": "boolean",
                      "default": "`true`",
                      "desc": "When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace."
                    },
                    {
                      "textRaw": "`timeout` {integer} Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer.",
                      "name": "timeout",
                      "type": "integer",
                      "desc": "Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer."
                    },
                    {
                      "textRaw": "`breakOnSigint` {boolean} If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that. **Default:** `false`.",
                      "name": "breakOnSigint",
                      "type": "boolean",
                      "default": "`false`",
                      "desc": "If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that."
                    },
                    {
                      "textRaw": "`contextName` {string} Human-readable name of the newly created context. **Default:** `'VM Context i'`, where `i` is an ascending numerical index of the created context.",
                      "name": "contextName",
                      "type": "string",
                      "default": "`'VM Context i'`, where `i` is an ascending numerical index of the created context",
                      "desc": "Human-readable name of the newly created context."
                    },
                    {
                      "textRaw": "`contextOrigin` {string} [Origin][origin] corresponding to the newly created context for display purposes. The origin should be formatted like a URL, but with only the scheme, host, and port (if necessary), like the value of the [`url.origin`][] property of a [`URL`][] object. Most notably, this string should omit the trailing slash, as that denotes a path. **Default:** `''`.",
                      "name": "contextOrigin",
                      "type": "string",
                      "default": "`''`",
                      "desc": "[Origin][origin] corresponding to the newly created context for display purposes. The origin should be formatted like a URL, but with only the scheme, host, and port (if necessary), like the value of the [`url.origin`][] property of a [`URL`][] object. Most notably, this string should omit the trailing slash, as that denotes a path."
                    },
                    {
                      "textRaw": "`contextCodeGeneration` {Object}",
                      "name": "contextCodeGeneration",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`strings` {boolean} If set to false any calls to `eval` or function constructors (`Function`, `GeneratorFunction`, etc) will throw an `EvalError`. **Default:** `true`.",
                          "name": "strings",
                          "type": "boolean",
                          "default": "`true`",
                          "desc": "If set to false any calls to `eval` or function constructors (`Function`, `GeneratorFunction`, etc) will throw an `EvalError`."
                        },
                        {
                          "textRaw": "`wasm` {boolean} If set to false any attempt to compile a WebAssembly module will throw a `WebAssembly.CompileError`. **Default:** `true`.",
                          "name": "wasm",
                          "type": "boolean",
                          "default": "`true`",
                          "desc": "If set to false any attempt to compile a WebAssembly module will throw a `WebAssembly.CompileError`."
                        }
                      ]
                    },
                    {
                      "textRaw": "`cachedData` {Buffer|TypedArray|DataView} Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source.",
                      "name": "cachedData",
                      "type": "Buffer|TypedArray|DataView",
                      "desc": "Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source."
                    },
                    {
                      "textRaw": "`importModuleDynamically` {Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER} Used to specify the how the modules should be loaded during the evaluation of this script when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][].",
                      "name": "importModuleDynamically",
                      "type": "Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER",
                      "desc": "Used to specify the how the modules should be loaded during the evaluation of this script when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][]."
                    },
                    {
                      "textRaw": "`microtaskMode` {string} If set to `afterEvaluate`, microtasks (tasks scheduled through `Promise`s and `async function`s) will be run immediately after the script has run. They are included in the `timeout` and `breakOnSigint` scopes in that case.",
                      "name": "microtaskMode",
                      "type": "string",
                      "desc": "If set to `afterEvaluate`, microtasks (tasks scheduled through `Promise`s and `async function`s) will be run immediately after the script has run. They are included in the `timeout` and `breakOnSigint` scopes in that case."
                    }
                  ]
                }
              ]
            }
          ],
          "desc": "<p>This method is a shortcut to\n<code>(new vm.Script(code, options)).runInContext(vm.createContext(options), options)</code>.\nIf <code>options</code> is a string, then it specifies the filename.</p>\n<p>It does several things at once:</p>\n<ol>\n<li>Creates a new context.</li>\n<li>If <code>contextObject</code> is an object, <a href=\"#what-does-it-mean-to-contextify-an-object\">contextifies</a> it with the new context.\nIf  <code>contextObject</code> is undefined, creates a new object and <a href=\"#what-does-it-mean-to-contextify-an-object\">contextifies</a> it.\nIf <code>contextObject</code> is <a href=\"#vmconstantsdont_contextify\"><code>vm.constants.DONT_CONTEXTIFY</code></a>, don't <a href=\"#what-does-it-mean-to-contextify-an-object\">contextify</a> anything.</li>\n<li>Compiles the code as a<code>vm.Script</code></li>\n<li>Runs the compield code within the created context. The code does not have access to the scope in\nwhich this method is called.</li>\n<li>Returns the result.</li>\n</ol>\n<p>The following example compiles and executes code that increments a global\nvariable and sets a new one. These globals are contained in the <code>contextObject</code>.</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nconst contextObject = {\n  animal: 'cat',\n  count: 2,\n};\n\nvm.runInNewContext('count += 1; name = \"kitty\"', contextObject);\nconsole.log(contextObject);\n// Prints: { animal: 'cat', count: 3, name: 'kitty' }\n\n// This would throw if the context is created from a contextified object.\n// vm.constants.DONT_CONTEXTIFY allows creating contexts with ordinary global objects that\n// can be frozen.\nconst frozenContext = vm.runInNewContext('Object.freeze(globalThis); globalThis;', vm.constants.DONT_CONTEXTIFY);\n</code></pre>"
        },
        {
          "textRaw": "`vm.runInThisContext(code[, options])`",
          "type": "method",
          "name": "runInThisContext",
          "meta": {
            "added": [
              "v0.3.1"
            ],
            "changes": [
              {
                "version": [
                  "v20.12.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/51244",
                "description": "Added support for `vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`."
              },
              {
                "version": [
                  "v17.0.0",
                  "v16.12.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/40249",
                "description": "Added support for import attributes to the `importModuleDynamically` parameter."
              },
              {
                "version": "v6.3.0",
                "pr-url": "https://github.com/nodejs/node/pull/6635",
                "description": "The `breakOnSigint` option is supported now."
              }
            ]
          },
          "signatures": [
            {
              "return": {
                "textRaw": "Returns: {any} the result of the very last statement executed in the script.",
                "name": "return",
                "type": "any",
                "desc": "the result of the very last statement executed in the script."
              },
              "params": [
                {
                  "textRaw": "`code` {string} The JavaScript code to compile and run.",
                  "name": "code",
                  "type": "string",
                  "desc": "The JavaScript code to compile and run."
                },
                {
                  "textRaw": "`options` {Object|string}",
                  "name": "options",
                  "type": "Object|string",
                  "options": [
                    {
                      "textRaw": "`filename` {string} Specifies the filename used in stack traces produced by this script. **Default:** `'evalmachine.<anonymous>'`.",
                      "name": "filename",
                      "type": "string",
                      "default": "`'evalmachine.<anonymous>'`",
                      "desc": "Specifies the filename used in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`lineOffset` {number} Specifies the line number offset that is displayed in stack traces produced by this script. **Default:** `0`.",
                      "name": "lineOffset",
                      "type": "number",
                      "default": "`0`",
                      "desc": "Specifies the line number offset that is displayed in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`columnOffset` {number} Specifies the first-line column number offset that is displayed in stack traces produced by this script. **Default:** `0`.",
                      "name": "columnOffset",
                      "type": "number",
                      "default": "`0`",
                      "desc": "Specifies the first-line column number offset that is displayed in stack traces produced by this script."
                    },
                    {
                      "textRaw": "`displayErrors` {boolean} When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace. **Default:** `true`.",
                      "name": "displayErrors",
                      "type": "boolean",
                      "default": "`true`",
                      "desc": "When `true`, if an [`Error`][] occurs while compiling the `code`, the line of code causing the error is attached to the stack trace."
                    },
                    {
                      "textRaw": "`timeout` {integer} Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer.",
                      "name": "timeout",
                      "type": "integer",
                      "desc": "Specifies the number of milliseconds to execute `code` before terminating execution. If execution is terminated, an [`Error`][] will be thrown. This value must be a strictly positive integer."
                    },
                    {
                      "textRaw": "`breakOnSigint` {boolean} If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that. **Default:** `false`.",
                      "name": "breakOnSigint",
                      "type": "boolean",
                      "default": "`false`",
                      "desc": "If `true`, receiving `SIGINT` (<kbd>Ctrl</kbd>+<kbd>C</kbd>) will terminate execution and throw an [`Error`][]. Existing handlers for the event that have been attached via `process.on('SIGINT')` are disabled during script execution, but continue to work after that."
                    },
                    {
                      "textRaw": "`cachedData` {Buffer|TypedArray|DataView} Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source.",
                      "name": "cachedData",
                      "type": "Buffer|TypedArray|DataView",
                      "desc": "Provides an optional `Buffer` or `TypedArray`, or `DataView` with V8's code cache data for the supplied source."
                    },
                    {
                      "textRaw": "`importModuleDynamically` {Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER} Used to specify the how the modules should be loaded during the evaluation of this script when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][].",
                      "name": "importModuleDynamically",
                      "type": "Function|vm.constants.USE\\_MAIN\\_CONTEXT\\_DEFAULT\\_LOADER",
                      "desc": "Used to specify the how the modules should be loaded during the evaluation of this script when `import()` is called. This option is part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see [Support of dynamic `import()` in compilation APIs][]."
                    }
                  ]
                }
              ]
            }
          ],
          "desc": "<p><code>vm.runInThisContext()</code> compiles <code>code</code>, runs it within the context of the\ncurrent <code>global</code> and returns the result. Running code does not have access to\nlocal scope, but does have access to the current <code>global</code> object.</p>\n<p>If <code>options</code> is a string, then it specifies the filename.</p>\n<p>The following example illustrates using both <code>vm.runInThisContext()</code> and\nthe JavaScript <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval\"><code>eval()</code></a> function to run the same code:</p>\n<!-- eslint-disable prefer-const -->\n<pre><code class=\"language-js\">const vm = require('node:vm');\nlet localVar = 'initial value';\n\nconst vmResult = vm.runInThisContext('localVar = \"vm\";');\nconsole.log(`vmResult: '${vmResult}', localVar: '${localVar}'`);\n// Prints: vmResult: 'vm', localVar: 'initial value'\n\nconst evalResult = eval('localVar = \"eval\";');\nconsole.log(`evalResult: '${evalResult}', localVar: '${localVar}'`);\n// Prints: evalResult: 'eval', localVar: 'eval'\n</code></pre>\n<p>Because <code>vm.runInThisContext()</code> does not have access to the local scope,\n<code>localVar</code> is unchanged. In contrast, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval\"><code>eval()</code></a> <em>does</em> have access to the\nlocal scope, so the value <code>localVar</code> is changed. In this way\n<code>vm.runInThisContext()</code> is much like an <a href=\"https://es5.github.io/#x10.4.2\">indirect <code>eval()</code> call</a>, e.g.\n<code>(0,eval)('code')</code>.</p>\n<h2>Example: Running an HTTP server within a VM</h2>\n<p>When using either <a href=\"#scriptruninthiscontextoptions\"><code>script.runInThisContext()</code></a> or\n<a href=\"#vmruninthiscontextcode-options\"><code>vm.runInThisContext()</code></a>, the code is executed within the current V8 global\ncontext. The code passed to this VM context will have its own isolated scope.</p>\n<p>In order to run a simple web server using the <code>node:http</code> module the code passed\nto the context must either call <code>require('node:http')</code> on its own, or have a\nreference to the <code>node:http</code> module passed to it. For instance:</p>\n<pre><code class=\"language-js\">'use strict';\nconst vm = require('node:vm');\n\nconst code = `\n((require) => {\n  const http = require('node:http');\n\n  http.createServer((request, response) => {\n    response.writeHead(200, { 'Content-Type': 'text/plain' });\n    response.end('Hello World\\\\n');\n  }).listen(8124);\n\n  console.log('Server running at http://127.0.0.1:8124/');\n})`;\n\nvm.runInThisContext(code)(require);\n</code></pre>\n<p>The <code>require()</code> in the above case shares the state with the context it is\npassed from. This may introduce risks when untrusted code is executed, e.g.\naltering objects in the context in unwanted ways.</p>"
        }
      ],
      "properties": [
        {
          "textRaw": "`constants` {Object}",
          "type": "Object",
          "name": "constants",
          "meta": {
            "added": [
              "v20.12.0"
            ],
            "changes": []
          },
          "desc": "<p>Returns an object containing commonly used constants for VM operations.</p>",
          "properties": [
            {
              "textRaw": "`vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`",
              "name": "USE_MAIN_CONTEXT_DEFAULT_LOADER",
              "meta": {
                "added": [
                  "v20.12.0"
                ],
                "changes": []
              },
              "stability": 1,
              "stabilityText": ".1 - Active development",
              "desc": "<p>A constant that can be used as the <code>importModuleDynamically</code> option to\n<code>vm.Script</code> and <code>vm.compileFunction()</code> so that Node.js uses the default\nESM loader from the main context to load the requested module.</p>\n<p>For detailed information, see\n<a href=\"#support-of-dynamic-import-in-compilation-apis\">Support of dynamic <code>import()</code> in compilation APIs</a>.</p>"
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "What does it mean to \"contextify\" an object?",
          "name": "what_does_it_mean_to_\"contextify\"_an_object?",
          "desc": "<p>All JavaScript executed within Node.js runs within the scope of a \"context\".\nAccording to the <a href=\"https://v8.dev/docs/embed#contexts\">V8 Embedder's Guide</a>:</p>\n<blockquote>\n<p>In V8, a context is an execution environment that allows separate, unrelated,\nJavaScript applications to run in a single instance of V8. You must explicitly\nspecify the context in which you want any JavaScript code to be run.</p>\n</blockquote>\n<p>When the method <code>vm.createContext()</code> is called with an object, the <code>contextObject</code> argument\nwill be used to wrap the global object of a new instance of a V8 Context\n(if <code>contextObject</code> is <code>undefined</code>, a new object will be created from the current context\nbefore its contextified). This V8 Context provides the <code>code</code> run using the <code>node:vm</code>\nmodule's methods with an isolated global environment within which it can operate.\nThe process of creating the V8 Context and associating it with the <code>contextObject</code>\nin the outer context is what this document refers to as \"contextifying\" the object.</p>\n<p>The contextifying would introduce some quirks to the <code>globalThis</code> value in the context.\nFor example, it cannot be frozen, and it is not reference equal to the <code>contextObject</code>\nin the outer context.</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\n// An undefined `contextObject` option makes the global object contextified.\nconst context = vm.createContext();\nconsole.log(vm.runInContext('globalThis', context) === context);  // false\n// A contextified global object cannot be frozen.\ntry {\n  vm.runInContext('Object.freeze(globalThis);', context);\n} catch (e) {\n  console.log(e); // TypeError: Cannot freeze\n}\nconsole.log(vm.runInContext('globalThis.foo = 1; foo;', context));  // 1\n</code></pre>\n<p>To create a context with an ordinary global object and get access to a global proxy in\nthe outer context with fewer quirks, specify <code>vm.constants.DONT_CONTEXTIFY</code> as the\n<code>contextObject</code> argument.</p>",
          "properties": [
            {
              "textRaw": "`vm.constants.DONT_CONTEXTIFY`",
              "name": "DONT_CONTEXTIFY",
              "desc": "<p>This constant, when used as the <code>contextObject</code> argument in vm APIs, instructs Node.js to create\na context without wrapping its global object with another object in a Node.js-specific manner.\nAs a result, the <code>globalThis</code> value inside the new context would behave more closely to an ordinary\none.</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\n// Use vm.constants.DONT_CONTEXTIFY to freeze the global object.\nconst context = vm.createContext(vm.constants.DONT_CONTEXTIFY);\nvm.runInContext('Object.freeze(globalThis);', context);\ntry {\n  vm.runInContext('bar = 1; bar;', context);\n} catch (e) {\n  console.log(e); // Uncaught ReferenceError: bar is not defined\n}\n</code></pre>\n<p>When <code>vm.constants.DONT_CONTEXTIFY</code> is used as the <code>contextObject</code> argument to <a href=\"#vmcreatecontextcontextobject-options\"><code>vm.createContext()</code></a>,\nthe returned object is a proxy-like object to the global object in the newly created context with\nfewer Node.js-specific quirks. It is reference equal to the <code>globalThis</code> value in the new context,\ncan be modified from outside the context, and can be used to access built-ins in the new context directly.</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nconst context = vm.createContext(vm.constants.DONT_CONTEXTIFY);\n\n// Returned object is reference equal to globalThis in the new context.\nconsole.log(vm.runInContext('globalThis', context) === context);  // true\n\n// Can be used to access globals in the new context directly.\nconsole.log(context.Array);  // [Function: Array]\nvm.runInContext('foo = 1;', context);\nconsole.log(context.foo);  // 1\ncontext.bar = 1;\nconsole.log(vm.runInContext('bar;', context));  // 1\n\n// Can be frozen and it affects the inner context.\nObject.freeze(context);\ntry {\n  vm.runInContext('baz = 1; baz;', context);\n} catch (e) {\n  console.log(e); // Uncaught ReferenceError: baz is not defined\n}\n</code></pre>"
            }
          ],
          "type": "module",
          "displayName": "What does it mean to \"contextify\" an object?"
        },
        {
          "textRaw": "Timeout interactions with asynchronous tasks and Promises",
          "name": "timeout_interactions_with_asynchronous_tasks_and_promises",
          "desc": "<p><code>Promise</code>s and <code>async function</code>s can schedule tasks run by the JavaScript\nengine asynchronously. By default, these tasks are run after all JavaScript\nfunctions on the current stack are done executing.\nThis allows escaping the functionality of the <code>timeout</code> and\n<code>breakOnSigint</code> options.</p>\n<p>For example, the following code executed by <code>vm.runInNewContext()</code> with a\ntimeout of 5 milliseconds schedules an infinite loop to run after a promise\nresolves. The scheduled loop is never interrupted by the timeout:</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nfunction loop() {\n  console.log('entering loop');\n  while (1) console.log(Date.now());\n}\n\nvm.runInNewContext(\n  'Promise.resolve().then(() => loop());',\n  { loop, console },\n  { timeout: 5 },\n);\n// This is printed *before* 'entering loop' (!)\nconsole.log('done executing');\n</code></pre>\n<p>This can be addressed by passing <code>microtaskMode: 'afterEvaluate'</code> to the code\nthat creates the <code>Context</code>:</p>\n<pre><code class=\"language-js\">const vm = require('node:vm');\n\nfunction loop() {\n  while (1) console.log(Date.now());\n}\n\nvm.runInNewContext(\n  'Promise.resolve().then(() => loop());',\n  { loop, console },\n  { timeout: 5, microtaskMode: 'afterEvaluate' },\n);\n</code></pre>\n<p>In this case, the microtask scheduled through <code>promise.then()</code> will be run\nbefore returning from <code>vm.runInNewContext()</code>, and will be interrupted\nby the <code>timeout</code> functionality. This applies only to code running in a\n<code>vm.Context</code>, so e.g. <a href=\"#vmruninthiscontextcode-options\"><code>vm.runInThisContext()</code></a> does not take this option.</p>\n<p>Promise callbacks are entered into the microtask queue of the context in which\nthey were created. For example, if <code>() => loop()</code> is replaced with just <code>loop</code>\nin the above example, then <code>loop</code> will be pushed into the global microtask\nqueue, because it is a function from the outer (main) context, and thus will\nalso be able to escape the timeout.</p>\n<p>If asynchronous scheduling functions such as <code>process.nextTick()</code>,\n<code>queueMicrotask()</code>, <code>setTimeout()</code>, <code>setImmediate()</code>, etc. are made available\ninside a <code>vm.Context</code>, functions passed to them will be added to global queues,\nwhich are shared by all contexts. Therefore, callbacks passed to those functions\nare not controllable through the timeout either.</p>",
          "type": "module",
          "displayName": "Timeout interactions with asynchronous tasks and Promises"
        },
        {
          "textRaw": "Support of dynamic `import()` in compilation APIs",
          "name": "support_of_dynamic_`import()`_in_compilation_apis",
          "desc": "<p>The following APIs support an <code>importModuleDynamically</code> option to enable dynamic\n<code>import()</code> in code compiled by the vm module.</p>\n<ul>\n<li><code>new vm.Script</code></li>\n<li><code>vm.compileFunction()</code></li>\n<li><code>new vm.SourceTextModule</code></li>\n<li><code>vm.runInThisContext()</code></li>\n<li><code>vm.runInContext()</code></li>\n<li><code>vm.runInNewContext()</code></li>\n<li><code>vm.createContext()</code></li>\n</ul>\n<p>This option is still part of the experimental modules API. We do not recommend\nusing it in a production environment.</p>",
          "modules": [
            {
              "textRaw": "When the `importModuleDynamically` option is not specified or undefined",
              "name": "when_the_`importmoduledynamically`_option_is_not_specified_or_undefined",
              "desc": "<p>If this option is not specified, or if it's <code>undefined</code>, code containing\n<code>import()</code> can still be compiled by the vm APIs, but when the compiled code is\nexecuted and it actually calls <code>import()</code>, the result will reject with\n<a href=\"errors.html#err_vm_dynamic_import_callback_missing\"><code>ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING</code></a>.</p>",
              "type": "module",
              "displayName": "When the `importModuleDynamically` option is not specified or undefined"
            },
            {
              "textRaw": "When `importModuleDynamically` is `vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`",
              "name": "when_`importmoduledynamically`_is_`vm.constants.use_main_context_default_loader`",
              "desc": "<p>This option is currently not supported for <code>vm.SourceTextModule</code>.</p>\n<p>With this option, when an <code>import()</code> is initiated in the compiled code, Node.js\nwould use the default ESM loader from the main context to load the requested\nmodule and return it to the code being executed.</p>\n<p>This gives access to Node.js built-in modules such as <code>fs</code> or <code>http</code>\nto the code being compiled. If the code is executed in a different context,\nbe aware that the objects created by modules loaded from the main context\nare still from the main context and not <code>instanceof</code> built-in classes in the\nnew context.</p>\n<pre><code class=\"language-cjs\">const { Script, constants } = require('node:vm');\nconst script = new Script(\n  'import(\"node:fs\").then(({readFile}) => readFile instanceof Function)',\n  { importModuleDynamically: constants.USE_MAIN_CONTEXT_DEFAULT_LOADER });\n\n// false: URL loaded from the main context is not an instance of the Function\n// class in the new context.\nscript.runInNewContext().then(console.log);\n</code></pre>\n<pre><code class=\"language-mjs\">import { Script, constants } from 'node:vm';\n\nconst script = new Script(\n  'import(\"node:fs\").then(({readFile}) => readFile instanceof Function)',\n  { importModuleDynamically: constants.USE_MAIN_CONTEXT_DEFAULT_LOADER });\n\n// false: URL loaded from the main context is not an instance of the Function\n// class in the new context.\nscript.runInNewContext().then(console.log);\n</code></pre>\n<p>This option also allows the script or function to load user modules:</p>\n<pre><code class=\"language-mjs\">import { Script, constants } from 'node:vm';\nimport { resolve } from 'node:path';\nimport { writeFileSync } from 'node:fs';\n\n// Write test.js and test.txt to the directory where the current script\n// being run is located.\nwriteFileSync(resolve(import.meta.dirname, 'test.mjs'),\n              'export const filename = \"./test.json\";');\nwriteFileSync(resolve(import.meta.dirname, 'test.json'),\n              '{\"hello\": \"world\"}');\n\n// Compile a script that loads test.mjs and then test.json\n// as if the script is placed in the same directory.\nconst script = new Script(\n  `(async function() {\n    const { filename } = await import('./test.mjs');\n    return import(filename, { with: { type: 'json' } })\n  })();`,\n  {\n    filename: resolve(import.meta.dirname, 'test-with-default.js'),\n    importModuleDynamically: constants.USE_MAIN_CONTEXT_DEFAULT_LOADER,\n  });\n\n// { default: { hello: 'world' } }\nscript.runInThisContext().then(console.log);\n</code></pre>\n<pre><code class=\"language-cjs\">const { Script, constants } = require('node:vm');\nconst { resolve } = require('node:path');\nconst { writeFileSync } = require('node:fs');\n\n// Write test.js and test.txt to the directory where the current script\n// being run is located.\nwriteFileSync(resolve(__dirname, 'test.mjs'),\n              'export const filename = \"./test.json\";');\nwriteFileSync(resolve(__dirname, 'test.json'),\n              '{\"hello\": \"world\"}');\n\n// Compile a script that loads test.mjs and then test.json\n// as if the script is placed in the same directory.\nconst script = new Script(\n  `(async function() {\n    const { filename } = await import('./test.mjs');\n    return import(filename, { with: { type: 'json' } })\n  })();`,\n  {\n    filename: resolve(__dirname, 'test-with-default.js'),\n    importModuleDynamically: constants.USE_MAIN_CONTEXT_DEFAULT_LOADER,\n  });\n\n// { default: { hello: 'world' } }\nscript.runInThisContext().then(console.log);\n</code></pre>\n<p>There are a few caveats with loading user modules using the default loader\nfrom the main context:</p>\n<ol>\n<li>The module being resolved would be relative to the <code>filename</code> option passed\nto <code>vm.Script</code> or <code>vm.compileFunction()</code>. The resolution can work with a\n<code>filename</code> that's either an absolute path or a URL string.  If <code>filename</code> is\na string that's neither an absolute path or a URL, or if it's undefined,\nthe resolution will be relative to the current working directory\nof the process. In the case of <code>vm.createContext()</code>, the resolution is always\nrelative to the current working directory since this option is only used when\nthere isn't a referrer script or module.</li>\n<li>For any given <code>filename</code> that resolves to a specific path, once the process\nmanages to load a particular module from that path, the result may be cached,\nand subsequent load of the same module from the same path would return the\nsame thing. If the <code>filename</code> is a URL string, the cache would not be hit\nif it has different search parameters. For <code>filename</code>s that are not URL\nstrings, there is currently no way to bypass the caching behavior.</li>\n</ol>",
              "type": "module",
              "displayName": "When `importModuleDynamically` is `vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`"
            },
            {
              "textRaw": "When `importModuleDynamically` is a function",
              "name": "when_`importmoduledynamically`_is_a_function",
              "desc": "<p>When <code>importModuleDynamically</code> is a function, it will be invoked when <code>import()</code>\nis called in the compiled code for users to customize how the requested module\nshould be compiled and evaluated. Currently, the Node.js instance must be\nlaunched with the <code>--experimental-vm-modules</code> flag for this option to work. If\nthe flag isn't set, this callback will be ignored. If the code evaluated\nactually calls to <code>import()</code>, the result will reject with\n<a href=\"errors.html#err_vm_dynamic_import_callback_missing_flag\"><code>ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG</code></a>.</p>\n<p>The callback <code>importModuleDynamically(specifier, referrer, importAttributes)</code>\nhas the following signature:</p>\n<ul>\n<li><code>specifier</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> specifier passed to <code>import()</code></li>\n<li><code>referrer</code> <a href=\"vm.html#class-vmscript\" class=\"type\">&lt;vm.Script&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\" class=\"type\">&lt;Function&gt;</a> | <a href=\"vm.html#class-vmsourcetextmodule\" class=\"type\">&lt;vm.SourceTextModule&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\" class=\"type\">&lt;Object&gt;</a>\nThe referrer is the compiled <code>vm.Script</code> for <code>new vm.Script</code>,\n<code>vm.runInThisContext</code>, <code>vm.runInContext</code> and <code>vm.runInNewContext</code>. It's the\ncompiled <code>Function</code> for <code>vm.compileFunction</code>, the compiled\n<code>vm.SourceTextModule</code> for <code>new vm.SourceTextModule</code>, and the context <code>Object</code>\nfor <code>vm.createContext()</code>.</li>\n<li><code>importAttributes</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\" class=\"type\">&lt;Object&gt;</a> The <code>\"with\"</code> value passed to the\n<a href=\"https://tc39.es/proposal-import-attributes/#sec-evaluate-import-call\"><code>optionsExpression</code></a> optional parameter, or an empty object if no value was\nprovided.</li>\n<li>Returns: <a href=\"https://tc39.github.io/ecma262/#sec-module-namespace-exotic-objects\" class=\"type\">&lt;Module Namespace Object&gt;</a> | <a href=\"vm.html#class-vmmodule\" class=\"type\">&lt;vm.Module&gt;</a> Returning a <code>vm.Module</code> is\nrecommended in order to take advantage of error tracking, and to avoid issues\nwith namespaces that contain <code>then</code> function exports.</li>\n</ul>\n<pre><code class=\"language-mjs\">// This script must be run with --experimental-vm-modules.\nimport { Script, SyntheticModule } from 'node:vm';\n\nconst script = new Script('import(\"foo.json\", { with: { type: \"json\" } })', {\n  async importModuleDynamically(specifier, referrer, importAttributes) {\n    console.log(specifier);  // 'foo.json'\n    console.log(referrer);   // The compiled script\n    console.log(importAttributes);  // { type: 'json' }\n    const m = new SyntheticModule(['bar'], () => { });\n    await m.link(() => { });\n    m.setExport('bar', { hello: 'world' });\n    return m;\n  },\n});\nconst result = await script.runInThisContext();\nconsole.log(result);  //  { bar: { hello: 'world' } }\n</code></pre>\n<pre><code class=\"language-cjs\">// This script must be run with --experimental-vm-modules.\nconst { Script, SyntheticModule } = require('node:vm');\n\n(async function main() {\n  const script = new Script('import(\"foo.json\", { with: { type: \"json\" } })', {\n    async importModuleDynamically(specifier, referrer, importAttributes) {\n      console.log(specifier);  // 'foo.json'\n      console.log(referrer);   // The compiled script\n      console.log(importAttributes);  // { type: 'json' }\n      const m = new SyntheticModule(['bar'], () => { });\n      await m.link(() => { });\n      m.setExport('bar', { hello: 'world' });\n      return m;\n    },\n  });\n  const result = await script.runInThisContext();\n  console.log(result);  //  { bar: { hello: 'world' } }\n})();\n</code></pre>",
              "type": "module",
              "displayName": "When `importModuleDynamically` is a function"
            }
          ],
          "type": "module",
          "displayName": "Support of dynamic `import()` in compilation APIs"
        }
      ],
      "type": "module",
      "displayName": "vm"
    }
  ]
}